
<!DOCTYPE html>
<html lang="en-GB" dir="ltr">
<head>
  <meta charset="UTF-8" />
  <title>Range Slider - P4W Wiki</title>
  <style>
  body p { font-family: 'verdana', 'arial'; font-size: 16px; }
  h1 { font-family: 'arial' ; font-size: 32px; text-align: center; }
  h2 { font-family: 'arial' ; font-size: 24px; }
  </style>
</head>
<body>
<h1>A Reusable Range-Slider Control in AngularJS</h1>
<h2><span class="mw-headline" id="Rationale">Rationale</span></h2>
<p>I want to share an AngularJS learning experience. The goal is to develop a reusable range slider control. 
</p><p>The end result probably won't be all that useful - range slider controls are available in HTML5, and have been done before in JavaScript, JQuery, and in AngularJS.
</p><p>Still, it's a good exercise and a fun way to practice and experiment with Angular. Hopefully, when it's finished, I will have a control which I understand well enough to add further features and customized behaviour.
</p>
<h2><span class="mw-headline" id="Development_plan">Development plan</span></h2>
<p>Since I'm fairly new to Angular, and I don't really know what I'm doing, I will start with a tiny fragment of HTML and CSS, constructing the control from the ground up, adding features and behaviour as I go.
</p><p>I'll show my work, bugs and all, as I go along.
</p>
<h2><span class="mw-headline" id="Specification">Specification</span></h2>
<p>I am working on an AngularJS project which needs a range slider control.
</p><p>This image, cropped from a mock-up, is my spec.   
</p><p><img alt="Screenshot.jpg" src="Screenshot.jpg" width="311" height="39" />
</p><p>I need to be able to specify the min and max values, and, if the range extends from a negative to a positive value, then I want the negative and positive parts of the control shown in different colours.
</p>
<h2><span class="mw-headline" id="Starting_point">Starting point</span></h2>
<p>I had a quick look at the HTML for some existing range slider controls. I soon came up with the following HTML fragment, comprising three nested divs:
</p>
<pre>
 &lt;div class=&quot;slider-target&quot;&gt;
   &lt;div class=&quot;slider-origin&quot; style=&quot;left:60%&quot;&gt;
     &lt;div class=&quot;slider-handle&quot;&gt;&lt;/div&gt;
   &lt;/div&gt;
 &lt;/div&gt;
 
</pre>
<p>The outermost element is the background - the CSS looks like this:
</p>
<pre>.slider-target {
  position: relative;
  width: 90%;
  height: 20px;
  display: inline-block;
  border-radius: 4px;
  border: 1px solid #e0e0e0;
  background-color: #f0f0f0;
}
</pre>
<p>The next element is used to anchor the slider's handle. Its left edge position (I have set it to 60% in an HTML style attribute) is given as a percentage of the target width, overriding the value given in the CSS:
</p>
<pre>.slider-origin {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
}
</pre>
<p>The third element is the handle itself. I have arranged the CSS so that it is centred horizontally on the left edge of the parent element (the origin) and centred vertically on the outer element (the target).
</p>
<pre>.slider-handle {
  position: relative;
  width: 26px;
  height: 26px;
  left: -12px;
  top: -4px;
  display: inline-block;
  border-radius: 4px;
  border: 1px solid #e0e0e0;
  background-color: #808080;
}
</pre>
<p>Here's what it looks like in the browser:
</p><p><img alt="Slider1.jpg" src="Slider1.jpg" width="637" height="98" />
</p>
<h2><span class="mw-headline" id="Step_2_-_Angularize_the_page">Step 2 - Angularize the page</span></h2>
<p>Here is the full HTML:
</p>
<pre>
 &lt;!DOCTYPE html&gt;
 &lt;html ng-app=&quot;exampleApp&quot;&gt;
   &lt;head&gt;
     &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.4.9/angular.js&quot;&gt;&lt;/script&gt;
     &lt;link rel=&quot;stylesheet&quot; href=&quot;https://netdna.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&quot;&gt;
     &lt;link rel=&quot;stylesheet&quot; href=&quot;slider2.css&quot;&gt;
     &lt;script&gt;
       angular.module(&quot;exampleApp&quot;, [])
         .controller(&quot;sliderCtrl&quot;, function($scope) {
           $scope.settings = {
             value: &quot;60&quot;
           }
         })
     &lt;/script&gt;
   &lt;/head&gt;
   &lt;body ng-controller=&quot;sliderCtrl&quot;&gt;
     &lt;div class=&quot;container&quot; style=&quot;padding:20px&quot;&gt;
       &lt;div class=&quot;slider-target&quot;&gt;
         &lt;div class=&quot;slider-origin&quot; ng-style=&quot;{'left':settings.value+'%'}&quot;&gt;
           &lt;div class=&quot;slider-handle&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-expand slider-icon&quot;&gt;&lt;/span&gt;&lt;/div&gt;
         &lt;/div&gt;
       &lt;/div&gt;
     &lt;/div&gt;
     &lt;input type=&quot;text&quot; ng-model=&quot;settings.value&quot;&gt;
   &lt;/body&gt;
 &lt;/html&gt;
 
</pre>
<p>I have used a Bootstrap glyphicon to add some styling to the slider handle. Here's the CSS for the handle and the glyphicon:
</p>
<pre>.slider-handle {
  position: relative;
  width: 20px;
  height: 18px;
  left: -10px;
  display: inline-block;
  background-color: #202020;
}
</pre>
<pre>.slider-icon {
  position: relative;
  font-size: 28px;
  top: -5px;
  left: -3px;
  color: green;
}
</pre>
<p>You can see that I have achieved the green-on-black effect by reducing the size of the slider-handle element, and giving it a dark background. Then I position the larger glyphicon over the top of the handle.
</p><p>The AngularJS is pretty basic:
</p>
<ul>
<li> I have added a controller which exposes (via its scope) a value representing the handle position.
</li>
<li> I have used an angular ng-style directive to bind the left edge position of the slider-origin element to the value in the controller's scope. 
</li>
<li> Finally, I have added an HTML input element with a two-way binding between the view and the controller, which allows me to change the value, and hence the position of the handle.
</li>
</ul>
<p>Here's what it looks like in a browser:
</p><p><img alt="Slider2.jpg" src="Slider2.jpg" width="626" height="138" />
</p>
<h2><span class="mw-headline" id="Step_3_-_Background_colours">Step 3 - Background colours</span></h2>
<p>The next thing I want to do is to add a variable to my controller's scope which represents the zero position in the slider's range of values.
To the left of the zero position, the slider will have a red background, and to the right it will be blue.
</p><p>Here's the whole HTML file:
</p>
<pre>
 &lt;!DOCTYPE html&gt;
 &lt;html ng-app=&quot;exampleApp&quot;&gt;
   &lt;head&gt;
     &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.4.9/angular.js&quot;&gt;&lt;/script&gt;
     &lt;link rel=&quot;stylesheet&quot; href=&quot;https://netdna.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&quot;&gt;
     &lt;link rel=&quot;stylesheet&quot; href=&quot;slider3.css&quot;&gt;
     &lt;script&gt;
       angular.module(&quot;exampleApp&quot;, [])
         .controller(&quot;sliderCtrl&quot;, function($scope) {
           $scope.settings = {
             handlepos: &quot;60&quot;,
             zeropos: &quot;33&quot;
           }
         })
     &lt;/script&gt;
   &lt;/head&gt;
   &lt;body ng-controller=&quot;sliderCtrl&quot;&gt;
     &lt;div class=&quot;container&quot; style=&quot;padding:20px;&quot;&gt;
       &lt;div class=&quot;slider-target&quot; style=&quot;margin:20px&quot;&gt;
         &lt;div class=&quot;slider-origin slider-negative&quot; ng-style=&quot;{'right':settings.zeropos+'%'}&quot;&gt;&lt;/div&gt;
         &lt;div class=&quot;slider-origin slider-positive&quot; ng-style=&quot;{'left':settings.zeropos+'%'}&quot;&gt;&lt;/div&gt;
         &lt;div class=&quot;slider-origin&quot; ng-style=&quot;{'left':settings.handlepos+'%'}&quot;&gt;
           &lt;div class=&quot;slider-handle&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-expand slider-icon&quot;&gt;&lt;/span&gt;&lt;/div&gt;
         &lt;/div&gt;
       &lt;/div&gt;
       &lt;form&gt;
         &lt;div class=&quot;form-group&quot;&gt;
           &lt;label for=&quot;handlepos&quot;&gt;Handle Position&lt;/label&gt;
           &lt;input id=&quot;handlepos&quot; type=&quot;text&quot; ng-model=&quot;settings.handlepos&quot;&gt;
         &lt;/div&gt;
         &lt;div class=&quot;form-group&quot;&gt;
           &lt;label for=&quot;handlepos&quot;&gt;Zero Position&lt;/label&gt;
           &lt;input id=&quot;zeropos&quot; type=&quot;text&quot; ng-model=&quot;settings.zeropos&quot;&gt;
         &lt;/div&gt;
       &lt;/form&gt;
     &lt;/div&gt;
   &lt;/body&gt;
 &lt;/html&gt;
 
</pre>
<p>And here's the CSS for the two background elements:
</p>
<pre>
 .slider-negative {
   background-color:red;
   border-top-left-radius:4px;
   border-bottom-left-radius:4px;
 }

 .slider-positive {
   background-color:blue;
   border-top-right-radius:4px;
   border-bottom-right-radius:4px;
 }
 
</pre>
<p>I have just added a couple of background elements coloured red and blue respectively.
Here's a screenshot from the browser:
</p><p><img alt="Slider3a.jpg" src="Slider3a.jpg" width="650" height="212" />
</p><p>That looks ok, but I'm thinking that the new elements are not actually both necessary, and there's a bug in the positioning:
</p><p><img alt="Slider3b.jpg" src="Slider3b.jpg" width="652" height="193" />
</p><p>I don't actually know what the problem is here, but I'm going to fix it by removing the slider-negative element, and giving the target element a red background. That's better:
</p><p><<img alt="Slider3c.jpg" src="Slider3c.jpg" width="653" height="206" />
</p>
<h2><span class="mw-headline" id="Step_4_-_Range_settings">Step 4 - Range settings</span></h2>
<p>My control needs to encapsulate a range of values, from a given minimum to a given maximum. There will be some maths required in order to convert between the value represented by the slider handle, and its position given as a percentage of the width of the slider. Here's the Angular controller:
</p>
<pre>
  angular.module(&quot;exampleApp&quot;, [])
  .controller(&quot;sliderCtrl&quot;, function($scope) {
    $scope.settings = {
      range: {
        min: -50,
        max: 100
      },
      value: 50
    }

    // Calculate the handle position as a percentage of the slider's width
    $scope.handlePos = function() {
      var val = ((($scope.settings.value-$scope.settings.range.min) * 100)/($scope.settings.range.max - $scope.settings.range.min + 1))

      // clip the value so that it lies in the range 0 &lt;= val &lt;= 100
      if ( val &gt; 100 ) {
        val = 100
      }
      else if ( val &lt; 0 ) {
        val = 0
      }
      return val + &quot;%&quot;
    }
		  
    // Calculate the zero position as a percentage of the slider's width
    $scope.zeroPos = function() {
      var val = (($scope.settings.range.min * -100)/($scope.settings.range.max - $scope.settings.range.min + 1))

      // clip the value so that it lies in the range 0 &lt;= val &lt;= 100
      if ( val &gt; 100 ) {
        val = 100
      }
      else if ( val &lt; 0 ) {
        val = 0
      }
      return val + &quot;%&quot;
    }
  })
 
</pre>
<p>I have changed the scope's settings object to represent the minimum and maximum values of the slider, and the current value, indcated by the slider's handle.
</p><p>I have also added behaviours which convert between slider values and percentages of the slider width.
</p><p>Here's how I use the controller behaviours in the HTML:
</p>
<pre>
 &lt;body ng-controller=&quot;sliderCtrl&quot;&gt;
   &lt;div class=&quot;container&quot; style=&quot;padding:20px;&quot;&gt;
     &lt;div class=&quot;slider-target&quot; style=&quot;margin:20px&quot;&gt;
       &lt;div class=&quot;slider-origin slider-positive&quot; ng-style=&quot;{'left':zeroPos()}&quot;&gt;&lt;/div&gt;
       &lt;div class=&quot;slider-origin&quot; ng-style=&quot;{'left':handlePos()}&quot;&gt;
         &lt;div my-draggable class=&quot;slider-handle&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-expand slider-icon&quot;&gt;&lt;/span&gt;&lt;/div&gt;
       &lt;/div&gt;
     &lt;/div&gt;
     &lt;form&gt;
       &lt;div class=&quot;form-group&quot;&gt;
         &lt;label for=&quot;handlepos&quot;&gt;Handle Position&lt;/label&gt;
         &lt;input id=&quot;handlepos&quot; type=&quot;text&quot; ng-model=&quot;settings.value&quot;&gt;
       &lt;/div&gt;
       &lt;div class=&quot;form-group&quot;&gt;
         &lt;label for=&quot;min&quot;&gt;Min Value&lt;/label&gt;
         &lt;input id=&quot;min&quot; type=&quot;text&quot; ng-model=&quot;settings.range.min&quot;&gt;
       &lt;/div&gt;
       &lt;div class=&quot;form-group&quot;&gt;
         &lt;label for=&quot;max&quot;&gt;Max Value&lt;/label&gt;
         &lt;input id=&quot;max&quot; type=&quot;text&quot; ng-model=&quot;settings.range.max&quot;&gt;
       &lt;/div&gt;
     &lt;/form&gt;
   &lt;/div&gt;
 &lt;/body&gt;
 
</pre>
<p>Here's a screenshot from the browser:
</p><p><img alt="Sider4.jpg" src="Sider4.jpg" width="653" height="243" />
</p>
<h2><span class="mw-headline" id="Step_5_-_Make_the_handle_draggable">Step 5 - Make the handle draggable</span></h2>
<p>Next, I want to make the slider handle draggable. There is an example of a draggable div on the AngularJS site <a rel="nofollow" class="external text" href="https://docs.angularjs.org/guide/directive">here</a>
</p><p>Here's the code:
</p>
<pre>
 angular.module('dragModule', [])
 .directive('myDraggable', ['$document', function($document) {
   return {
     link: function(scope, element, attr) {
       var startX = 0, startY = 0, x = 0, y = 0;

       element.css({
        position: 'relative',
        border: '1px solid red',
        backgroundColor: 'lightgrey',
        cursor: 'pointer'
       });

       element.on('mousedown', function(event) {
         // Prevent default dragging of selected content
         event.preventDefault();
         startX = event.pageX - x;
         startY = event.pageY - y;
         $document.on('mousemove', mousemove);
         $document.on('mouseup', mouseup);
       });

       function mousemove(event) {
         y = event.pageY - startY;
         x = event.pageX - startX;
         element.css({
           top: y + 'px',
           left:  x + 'px'
         });
       }

       function mouseup() {
         $document.off('mousemove', mousemove);
         $document.off('mouseup', mouseup);
       }
     }
   };
 }]);
 
</pre>
<p>I'm going to modify this directive so that it only allows horizontal movement, then I'm going to include the directive in my Angular controller and add the my-draggable attribute to my slider's handle. Here's the modified directive:
</p>
<pre>
 .directive('myDraggable', ['$document', function($document) {
   return {
     link: function(scope, element, attr) {
       var startX = 0, x = 0;
       var targetWidth = 0;
       var valueRange = 0;
       var startValue = 0;
 	  
       // clip a value to lie in a given range
       // range.min &lt;= value &lt;= range.max
       var clip = function(range, value){
         return Math.min(range.max, Math.max(range.min, value));
       }

       element.on('mousedown', function(event) {
         // get the width in pixels of the slider-target
         targetWidth = parseInt(element.parent().parent().prop('offsetWidth'));
         
         // get the range of the slider in terms of values
         valueRange = scope.settings.range.max - scope.settings.range.min + 1;

         // Prevent default dragging of selected content
         event.preventDefault();

         // start the drag
         startX = event.pageX;
         startValue = parseInt(scope.settings.value);
         $document.on('mousemove', mousemove);
         $document.on('mouseup', mouseup);
       });

       function mousemove(event) {
         x = event.pageX - startX;
         // the Angular controller needs to be told about this change to its scope
         scope.$apply(function() {
           scope.settings.value = clip(scope.settings.range, startValue + (x*valueRange)/targetWidth);
         });
         lastX = x;
       }

       function mouseup() {
         $document.off('mousemove', mousemove);
         $document.off('mouseup', mouseup);
       }
     }
   };
 
</pre>
<p>I have moved the cursor: pointer CSS into my css file, and, in the mousemove handler, instead of setting the position directly in the element's css, I update the value variable in the scope. This way, the scope takes care of setting the handle position, and reflects the value in the first &lt;input&gt; element.
</p><p>Here's the HTML which uses the directive:
</p>
<pre>
 &lt;div class=&quot;slider-target&quot; style=&quot;margin:20px&quot;&gt;
   &lt;div class=&quot;slider-origin slider-positive&quot; ng-style=&quot;{'left':zeroPos()}&quot;&gt;&lt;/div&gt;
   &lt;div class=&quot;slider-origin&quot; ng-style=&quot;{'left':handlePos()}&quot;&gt;
     &lt;div my-draggable class=&quot;slider-handle&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-expand slider-icon&quot;&gt;&lt;/span&gt;&lt;/div&gt;
   &lt;/div&gt;
 &lt;/div&gt;
 
</pre>
<p>Here's a screenshot:
</p><p><img alt="Slider4a.jpg" src="Slider4a.jpg" width="651" height="248" />
</p><p>This works ok, but really the directive should encapsulate the whole range control, not just the handle. Here are the changes needed to achieve this:
</p>
<pre>
 .directive('mySlider', ['$document', function($document) {
   return {
     link: function(scope, element, attr) {
       var startX = 0;
       var x = 0;
       var targetWidth = 0;
       var range = 0;
       var startValue = 0;
	  
       // find the handle element
       var elHandle = null;
       var children = element.children();
       for (var i=0; i&lt;children.length; i++) {
         if (children.eq(i).hasClass('slider-origin')) {
           var grandchildren = children.eq(i).children();
           for (var j=0; j&lt;grandchildren.length; j++) {
             if (grandchildren.eq(j).hasClass('slider-handle')) {
               elHandle = grandchildren.eq(j);
             }
           }
         }
       }
 
 ...
 
 &lt;div my-slider class=&quot;slider-target&quot; style=&quot;margin:20px&quot;&gt;
   &lt;div class=&quot;slider-positive&quot; ng-style=&quot;{'left':zeroPos()}&quot;&gt;&lt;/div&gt;
   &lt;div class=&quot;slider-origin&quot; ng-style=&quot;{'left':handlePos()}&quot;&gt;
     &lt;div class=&quot;slider-handle&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-expand slider-icon&quot;&gt;&lt;/span&gt;&lt;/div&gt;
   &lt;/div&gt;
 &lt;/div&gt;
 
</pre>
<p><br />
I have added a function to traverse the slider's child elements and locate the slider handle. I don't know much about jqLite - is there a better/easier way than this?
</p>
<h2><span class="mw-headline" id="Step_6_-_Give_the_directive_its_own_scope">Step 6 - Give the directive its own scope</span></h2>
<p>To make this control reusable, it needs to encapsulate its properties and behaviours. That means it needs its own scope.
Let's have a go at that.
</p><p>There are lots of different ways in which directives can be isolated or can have one-way or two-way bindings to the controller's scope.
I need to get this right, so I am going to modify the HTML to include two sliders in a single controller's view. That way I can check whether the sliders operate independently of each other.
</p><p>The controller doesn't need it's behaviours any more. Those calculations are done in the slider directive now. All I need is the variables to bind to the properties exposed by the directive - namely the min, max, and value of the sliders. My two sliders will have the same min and max so my controller looks like this:
</p>
<pre>
 angular.module(&quot;exampleApp&quot;, [])
 .controller(&quot;sliderCtrl&quot;, function($scope, $interval) {
   $scope.settings = {
     range: {
       min: -250,
       max: 100
     },
     value1: 50,
     value2: -50
   } 
 })
 
</pre>
<p>Now I'm going to move the slider's HTML into a template which the directive can use:
</p>
<pre>
 &lt;script type=&quot;text/ng-template&quot; id=&quot;slidertemplate&quot;&gt;
   &lt;div class=&quot;slider-positive&quot;&gt;&lt;/div&gt;
   &lt;div class=&quot;slider-origin&quot;&gt;
     &lt;div class=&quot;slider-handle&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-expand slider-icon&quot;&gt;&lt;/span&gt;&lt;/div&gt;
   &lt;/div&gt;
 &lt;/script&gt;
 
 ...
 
 .directive('mySlider', ['$document', function($document) {
   return {
     template: function() {
       return angular.element(document.querySelector(&quot;#slidertemplate&quot;)).html();
     },
     scope: {
       min: &quot;=slidermin&quot;,
       max: &quot;=slidermax&quot;,
       value: &quot;=sliderval&quot;,	  
     },
 ...
 
</pre>
<p>There are three variables in the directive's scope and they have two-way bindings to the controller's scope (the two-way binding is indicated by the '=' symbol). The bindings are achieved via attributes in the HTML named slidermin, slidermax, and sliderval. Like this:
</p>
<pre>
 &lt;div my-slider slidermin=&quot;settings.range.min&quot; slidermax=&quot;settings.range.max&quot; sliderval=&quot;settings.value1&quot; ...
 &lt;div my-slider slidermin=&quot;settings.range.min&quot; slidermax=&quot;settings.range.max&quot; sliderval=&quot;settings.value2&quot; ...
 
</pre>
<p>What happens when the user changes a value in one of the &lt;input&gt; elements?
Angular will update the value of the variable in controller's scope, and the two-way binding will ensure that the corresponding value is updated in the directive's scope, but in order for the directive to adjust and re-render itself I need to set up some watchers:
</p>
<pre>
 ...
 //watchers
 scope.$watch('value', function(newValue) {
   elOrigin.css('left', handlePos())
 });
 scope.$watch('min', function(newValue) {
   elZero.css('left', zeroPos());
   elOrigin.css('left', handlePos());
 });
 scope.$watch('max', function(newValue) {
   elZero.css('left', zeroPos());
   elOrigin.css('left', handlePos());
 });
 ...	  
 
</pre>
<h2><span class="mw-headline" id="Last_Step_-_package_the_directive_in_a_module">Last Step - package the directive in a module</span></h2>
<p>The last step required to make my slider reusable is to package it in a module.
</p><p>I have replaced the template function in the directive with a simple string containing the template HTML.
I'm not sure what to do about the CSS - perhaps some kind person will help me?
</p><p>I want the directive, or the new module to contain the default styles for the slider elements, but I want it to be clear to other developers how to override these styles, for example to change the glyphicon on the handle, or the background colour of the target.
</p><p>For now, I will set the styles explicitly in the directive.
</p><p>For completeness, here is the finished code:
</p>
<pre>slider.js
</pre>
<pre>
      angular.module(&quot;slider&quot;, [])
      .directive('mySlider', ['$document', function($document) {
        return {
          template: 
		    '&lt;style&gt;'+
		    '.slider-target {'+
		    '  position: relative;'+
  		    '  width: 90%;'+
  		    '  height: 20px;'+
  		    '  display: inline-block;'+
  		    '  border-radius: 4px;'+
  		    '  border: 1px solid #e0e0e0;'+
  		    '  background-color: red;'+
		    '}'+
		    '.slider-origin {'+
  		    '  position: absolute;'+
  		    '  top: 0;'+
  		    '  left: 0;'+
  		    '  bottom: 0;'+
  		    '  right: 0;'+
		    '}'+
		    '.slider-positive {'+
  		    '  position: absolute;'+
  		    '  top: 0;'+
  		    '  left: 0;'+
  		    '  bottom: 0;'+
  		    '  right: 0;'+
  		    '  background-color:blue;'+
  		    '  border-top-right-radius:4px;'+
  		    '  border-bottom-right-radius:4px;'+
		    '}'+
		    '.slider-handle {'+
  		    '  position: relative;'+
  		    '  width: 20px;'+
  		    '  height: 18px;'+
  		    '  left: -10px;'+
  		    '  display: inline-block;'+
  		    '  background-color: #202020;'+
  		    '  cursor: &quot;pointer&quot;;'+
		    '}'+
		    '.slider-icon {'+
  		    '  position: relative;'+
 		    '  font-size: 28px;'+
  		    '  top: -5px;'+
  		    '  left: -3px;'+
  		    '  color: green;'+
		    '}'+
			'&lt;/style&gt;'+
		    '&lt;div class=&quot;slider-positive&quot;&gt;&lt;/div&gt;'+
		    '&lt;div class=&quot;slider-origin&quot;&gt;'+
			'  &lt;div class=&quot;slider-handle&quot;&gt;'+
			'    &lt;span class=&quot;glyphicon glyphicon-expand slider-icon&quot;&gt;&lt;/span&gt;'+
			'  &lt;/div&gt;'+
			'&lt;/div&gt;',
	      scope: {
	        min: &quot;=slidermin&quot;,
	        max: &quot;=slidermax&quot;,
            value: &quot;=sliderval&quot;,	  
	      },
          link: function(scope, element, attr) {
            var startX = 0;
	        var x = 0;
            var targetWidth = 0;
	        var valueRange = 0;
	        var startValue = 0;
	  
	        // make sure the value for the slider handle position
	        // is within the range of the control
            var clip = function(range, value){
		      return Math.min(range.max, Math.max(range.min, value));
	        }
	  
            // calculate the percentage position of the zero position
            // for controls where the range goes from negative to positive
            var zeroPos = function() {
              var zero = ((scope.min * -100)/(scope.max - scope.min + 1))
	          if ( zero &gt; 100 ) {
		        zero = 100
	          }
	          else if ( zero &lt; 0 ) {
		        zero = 0
	          }
              return zero + &quot;%&quot;;	  
	        } 
	  
            // calculate the percentage position of the left edge
	        // of the slider-origin element
            var handlePos = function() {
	          var val = (((scope.value-scope.min) * 100)/(scope.max - scope.min + 1))
		      if ( val &gt; 100 ) {
		        val = 100
		      }
		      else if ( val &lt; 0 ) {
		        val = 0
		      }
		      return val + &quot;%&quot;;
	        }

			element.addClass('slider-target');
	        // find the handle element;
	        var elHandle = null;
	        var elOrigin = null;
	        var elZero = null;
	  
	        var children = element.children();
	        for (var i=0; i&lt;children.length; i++) {
	          if (children.eq(i).hasClass('slider-origin')) {
		        elOrigin = children.eq(i);
		        var grandchildren = elOrigin.children();
		        for (var j=0; j&lt;grandchildren.length; j++) {
		          if (grandchildren.eq(j).hasClass('slider-handle')) {
			        elHandle = grandchildren.eq(j);
			      }
	            }
		      }
		      else if (children.eq(i).hasClass('slider-positive')) {
		        elZero = children.eq(i);
		      }
            }
            elZero.css('left', zeroPos());
            scope.value = clip({min:scope.min, max:scope.max}, scope.value);	  
            elOrigin.css('left', handlePos());
	  
	        //watchers
			scope.$watch('value', function(newValue) {
	          elOrigin.css('left', handlePos())
	        });
	        scope.$watch('min', function(newValue) {
	          elZero.css('left', zeroPos());
		      elOrigin.css('left', handlePos());
	        });
	        scope.$watch('max', function(newValue) {
	          elZero.css('left', zeroPos());
		      elOrigin.css('left', handlePos());
	        });
	  
            elHandle.on('mousedown', function(event) {
	          targetWidth = parseInt(element.prop('offsetWidth'));
		      valueRange = scope.max - scope.min + 1;
		
              // Prevent default dragging of selected content
              event.preventDefault();
              startX = event.pageX;
		      startValue = parseInt(scope.value);
              $document.on('mousemove', mousemove);
              $document.on('mouseup', mouseup);
            });

            function mousemove(event) {
              x = event.pageX - startX;
	          scope.$apply(function() {
		        scope.value = clip({min:scope.min, max:scope.max}, startValue + (x*valueRange)/targetWidth);
		      })
		      elOrigin.css('left', handlePos());
		      lastX = x;
            }

            function mouseup() {
              $document.off('mousemove', mousemove);
              $document.off('mouseup', mouseup);
            }
          }
        };
      }]);
 
</pre>
<pre>slidertest.html
</pre>
<pre>
 &lt;!DOCTYPE html&gt;
 &lt;html ng-app=&quot;exampleApp&quot;&gt;
   &lt;head&gt;
     &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.4.9/angular.js&quot;&gt;&lt;/script&gt;
     &lt;script src=&quot;slider.js&quot;&gt;&lt;/script&gt;
     &lt;link rel=&quot;stylesheet&quot; href=&quot;https://netdna.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&quot;&gt;
     &lt;link rel=&quot;stylesheet&quot; href=&quot;slider.css&quot;&gt;
     &lt;script&gt;
       angular.module(&quot;exampleApp&quot;, [&quot;slider&quot;])
       .controller(&quot;sliderCtrl&quot;, function($scope, $interval) {
         $scope.settings = {
           range: {
             min: -250,
             max: 100
           },
           value1: 50,
           value2: -50
         } 
       })
     &lt;/script&gt;
   &lt;/head&gt;
   &lt;body ng-controller=&quot;sliderCtrl&quot;&gt;
     &lt;div class=&quot;container&quot; style=&quot;padding:20px;&quot;&gt;
       &lt;div my-slider slidermin=&quot;settings.range.min&quot; slidermax=&quot;settings.range.max&quot; sliderval=&quot;settings.value1&quot; style=&quot;margin:20px&quot;&gt;&lt;/div&gt;
       &lt;div my-slider slidermin=&quot;settings.range.min&quot; slidermax=&quot;settings.range.max&quot; sliderval=&quot;settings.value2&quot; style=&quot;margin:20px&quot;&gt;&lt;/div&gt;
       &lt;form&gt;
         &lt;div class=&quot;form-group&quot;&gt;
           &lt;label for=&quot;handlepos&quot;&gt;Slider Value&lt;/label&gt;
           &lt;input id=&quot;handlepos&quot; type=&quot;text&quot; ng-model=&quot;settings.value1&quot;&gt;
         &lt;/div&gt;
         &lt;div class=&quot;form-group&quot;&gt;
           &lt;label for=&quot;handlepos&quot;&gt;Slider2 Value&lt;/label&gt;
           &lt;input id=&quot;handlepos&quot; type=&quot;text&quot; ng-model=&quot;settings.value2&quot;&gt;
         &lt;/div&gt;
         &lt;div class=&quot;form-group&quot;&gt;
           &lt;label for=&quot;handlepos&quot;&gt;Min Value&lt;/label&gt;
           &lt;input id=&quot;min&quot; type=&quot;text&quot; ng-model=&quot;settings.range.min&quot;&gt;
         &lt;/div&gt;
         &lt;div class=&quot;form-group&quot;&gt;
           &lt;label for=&quot;handlepos&quot;&gt;Max Value&lt;/label&gt;
           &lt;input id=&quot;max&quot; type=&quot;text&quot; ng-model=&quot;settings.range.max&quot;&gt;
         &lt;/div&gt;
       &lt;/form&gt;
     &lt;/div&gt;
   &lt;/body&gt;
 &lt;/html&gt;
 
</pre>
<h2><span class="mw-headline" id="What_next">What next</span></h2>
<p>Send me some feedback.
Sometime I'll try to implement the same thing with React - It will be interesting to see how it compares...
</p>
	</body>
</html>
